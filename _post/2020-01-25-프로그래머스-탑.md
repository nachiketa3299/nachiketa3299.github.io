# [탑](https://programmers.co.kr/learn/courses/30/lessons/42588)

## 문제 설명

수평 직선에 탑 `N`대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.

예를 들어 높이가 `6`, `9`, `5`, `7`, `4`인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 `4`인 다섯 번째 탑에서 발사한 신호는 높이가 `7`인 네 번째 탑이 수신하고, 높이가 `7`인 네 번째  탑의 신호는 높이가 `9`인 두 번째 탑이, 높이가 `5`인 세 번째 탑의 신호도 높이가 `9`인 두 번째 탑이 수신합니다. 높이가 `9`인 두 번째 탑과 높이가 `6`인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다.

| 송신 탑(높이) | 수신 탑(높이 |
| ------------- | ------------ |
| `5(4)`        | `4(7)`       |
| `4(7)`        | `2(9)`       |
| `3(5)`        | `2(9)`       |
| `2(9)`        | -            |
| `1(6)`        | -            |

맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 `heights`가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 반환 하도록 `solution` 함수를 작성해주세요.

## 제한 사항

- `heights`는 길이 `2` 이상 `100` 이하인 정수 배열입니다.
- 모든 탑의 높이는 `1` 이상 `100` 이하입니다.
- 신호를 수신하는 탑이 없으면 `0`으로 표시합니다.

## 입출력 예

| heights           | return            |
| ----------------- | ----------------- |
| `[6,9,5,7,4]`     | `[0,0,2,2,4]`     |
| `[3,9,9,3,5,7,2]` | `[0,0,0,3,3,3,6]` |
| `[1,5,3,6,7,6,5]` | `[0,0,2,0,0,5,6]` |

## 내 풀이

```python
def solution(heights):
    answer = []
    for tower_index, height in enumerate(heights):
        exist = False
        # 해당 탑 바로 왼쪽부터, 왼쪽 끝까지 해당 탑의 높이보다 큰지 검사한다. 
        for i in range(tower_index - 1, -1, -1):
            # 만약에 크다면, 그 탑의 인덱스를 정답에 추가한다. 그리고 수신한 타워가 있다는 플래그를 표시한다.
            if heights[i] > height:
                answer.append(i + 1)
                exist = True
                break

        # 플래그가 표시되지 않았다면, 해당 탑의 신호를 수신한 탑이 없다는 것이다. 따라서 0을 추가해준다.
        if not exist:
            answer.append(0)

    return answer

```

## 해설

특별히 어려울 것이 없는 문제이다. 

매 탑의 높이를 자기보다 왼쪽에 있는 탑의 높이와 비교하며, 처음으로 맞딱드리는 자신보다 높은 탑의 인덱스를 `answer`리스트에 추가하였고, 만약에 그런 탑이 없다면 `0`을 추가하였다. 이를 위해서 한번이라도 자신보다 큰 탑을 마주치면 반복문을 탈출하면서 그런 탑을 만났다는 표시를 남기기 위해 `exit`변수를 사용하였다. `exit`변수의 존재로 자신보다 큰 탑을 마주쳐서 반복문을 탈출한건지, 아니면 마주치지 않고 반복문을 다 돌아서 탈출한건지 구별할 수 있었다.

자신보다 왼쪽에 있는 리스트 요소와 비교하기 위해서 큰 수에서 시작해 내림차순으로 작은 수를 발생시키는 `range(START,END,STEP)`를 사용했다. 특히 리스트 인덱스는`0`번부터 시작이므로 `END`에 `-1`을 넣어주었다. 



## 알게 된 것

- 리스트의 순서를 거꾸로 뒤집으려면 `LIST_NAME.reverse()`와 `reversed(LIST_NAME)`을 사용한다. 이 둘은 `LIST_NAME.sort()`와 `sorted(LIST_NAME)`과 유사하게 작동한다. 하지만 이 문제에서는 결국 사용하지 않았다. 처음에 오른쪽을 기준으로 왼쪽을 비교한다는 것이 비직관적이라고 생각하여 리스트 자체를 역순으로 바꾸어 비교하려고 하였지만, 그렇게 되면 탑의 인덱스가 엉클어져서, 그게 그거라는 것을 깨달았다.

- 참고로 리스트의 요소를 역으로 슬라이싱 하려면, `LIST_NAME[START:END:STEP]`에서 `STEP`을 음수로 해야한다. 순방향 슬라이싱과 역방향 슬라이싱을 정리하면 다음과 같다. 아래와 같은 리스트가 있다고 하자.

  ```python
  >>> li = list(range(0, 40))
  
  >>> li
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]
  
  ```

  - __순방향 슬라이싱__의 경우, `START`와 `END`의 부호가 둘 다 양수라면 `START > END` 이며, 부호가 둘 다 음수라면 `START < END`이고 공통적으로 `STEP > 0` 이다.

    ```python
    >>> l[0:40:5]
    [0, 5, 10, 15, 20, 25, 30, 35]
    
    >>> l[-29:-2:3]
    [11, 14, 17, 20, 23, 26, 29, 32, 35]
    ```

    그러니까 아래와 같은 짓은 아무런 의미가 없다.

    ```python
    >>> l[0:40:-1]
    []
    ```

  - __역방향 슬라이싱__의 경우, `START`와 `END`의 부호가 둘 다 양수라면 같고 `START > END`이며, 부호가 둘 다 음수라면 `START > END`이고 공통적으로 `STEP < 0` 이다.

    ```python
    >>> l[39:0:-1]
    [39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    
    >>> l[-4:-20:-1]
    [36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21]
    ```

  - `START`와 `END`를 다른 부호로 설정할 수 있고 이 경우 한 리스트 요소에 부여된 음수/양수 주소처럼 작동하지만, __굳이 이렇게까지 자신을 고통에 빠트리며 헷갈리게 슬라이싱을 할 필요가 없다.__

  - 하다가 알게된건데 공통적으로 `START`와 `END`, 그리고 `STEP`은 리스트의 바운더리를 넘어서도 크게 문제가 없는 듯 하다. 리스트를 직접 호출하기 위한 `LIST_NANE[INDEX]`에서는 `INDEX`가 리스트의 범위를 초과하면 `IndexError`를 일으켰지만, 슬라이싱의 경우 융통성 있게 그 값과 가장 가까운 값으로 슬라이싱을 진행하는 듯 하다.

    ```python
    >>> l = [0, 1, 2]
    
    >>> l[-4]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    IndexError: list index out of range
        
    >>> l[-5:-1]
    [0, 1]
    
    ```

    

