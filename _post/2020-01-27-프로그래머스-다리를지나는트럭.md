# [다리를 지나는 트럭](https://programmers.co.kr/learn/courses/30/lessons/42583)

## 문제 설명

트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 `1`만큼 움직이며, 다리 길이는 `bridge_length`이고 다리는 무게 `weight`까지 견딥니다.

__※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.__

예를 들어, 길이가 `2`이고 `10`kg 무게를 견디는 다리가 있습니다. 무게가 `[7, 4, 5, 6]`kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.



| 경과 시간 | 다리를 지난 트럭 | 다리를 건너는 트럭 | 대기 트럭   |
| --------- | ---------------- | ------------------ | ----------- |
| `0`       | `[]`             | `[]`               | `[7,4,5,6]` |
| `1~2`     | `[]`             | `[7]`              | `[4,5,6]`   |
| `3`       | `[7]`            | `[4]`              | `[5,6]`     |
| `4`       | `[7]`            | `[4,5]`            | `[6]`       |
| `5`       | `[7,4]`          | `[5]`              | `[6]`       |
| `6~7`     | `[7,4,5]`        | `[6]`              | `[]`        |
| `8`       | `[7,4,5,6]`      | `[]`               | `[]`        |

따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.

`solution` 함수의 매개변수로 다리 길이 `bridge_length`, 다리가 견딜 수 있는 무게 `weight`, 트럭별 무게 `truck_weights`가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 반환하도록 `solution` 함수를 완성하세요.



## 제한 조건

- `bridge_length`는 `1` 이상 `10000` 이하입니다.

- `weight`는 `1` 이상 `10000` 이하입니다.

- `truck_weights`의 길이는 `1` 이상 `10000` 이하입니다.

- 모든 트럭의 무게는 `1` 이상 `weight` 이하입니다.

  

## 입출력 예

| `bridge_length` | `weight` | `truck_weights`                   | `return` |
| --------------- | -------- | --------------------------------- | -------- |
| `2`             | `10`     | `[7,4,5,6]`                       | `8`      |
| `100`           | `100`    | `[10]`                            | `101`    |
| `100`           | `100`    | `[10,10,10,10,10,10,10,10,10,10]` | `110`    |



## 나의 풀이

```python
def solution(bridge_length, weight, truck_weights):
    # 트럭은 bridge_length 초 만큼의 수명동안 bridge위에서 crossing 상태에 놓인다고 보면 됨.
    time_passed = 0

    # 대기하고있는 트럭들의 list인 trucks를 선언하는데, 이 경우 각 요소는 (해당 트럭 무게, 트럭이 다리에서 진행한 거리) 이다.
    trucks = [(w, 0) for w in truck_weights]

    crossed = []
    crossing = []

    while len(crossed) != len(truck_weights):
        # 시간을 1초 흐르게 하고 그 1초동안 일어난일을 루프에서 처리
        time_passed += 1
        
        # 아직 다리에 오르지 않고 대기하고 있는 트럭이 존재하는 경우, 트럭이 다리 무게를 고려하여 다리에 진입할지 말지 판단
        # truck, crossing 리스트 모두 스택으로 보았고, 최 좌측에서(top = 리스트 인덱스가 0) 스택 연산이 일어난다고 보았다.
        if trucks != []:
            if sum([w for (w, lf) in crossing if lf < bridge_length] + [trucks[0][0]]) <= weight:
                crossing.append(trucks.pop(0))

        # crossing의 모든 트럭들이 다리를 거리 1씩 전진
        crossing = list(map(lambda x: (x[0], x[1] + 1), crossing))

        # 만약에 트럭이 진행한 거리가, 다리의 길이보다 크다면 crossing스택에서 pop하여 crossed 리스트에 append한다.
        if crossing[0][1] > bridge_length:
            crossed.append(crossing.pop(0))
            
    return time_passed

```



## 해설

  정말 오래 걸렸다. 우선 문제의 상황이 제대로 이해되지 않아서, 시각화해보았다.

![프로그래머스_[Python]_다리를지나는트럭_그림자료](/Users/songjaemin/Documents/myProjects/for_blogger/프로그래머스_[Python]_다리를지나는트럭_그림자료.gif)



- 문제의 핵심은 __한 개 이상의 _스택_ 을 만들어, 언제 `pop` 과 `push` 를 할 지 조건을 설정해 주는 것__ 이다.



- `while` 문 하나를 두고, _"루프 한 번을 도는 것"_을  _"`1`초가 흐르는 것"_  이라고 보았다. 
- 흘러간 시간의 총합을 `time_passed` 변수에 저장하였다.



- 문제를 해결하기 위해 `trucks`, `crossing`, `crossed` 3개의 리스트를 만들었다.

- 매 `while` 루프마다 `trucks`, `crossing` 에서 `pop` 연산과 `push`(`append`) 할 지 말지 판단한다. 이는 매 초마다 대기하는 트럭이 다리에 오를지 혹은 다리를 건너는 중인 트럭이 다리를 다 건넜는지 판단한다는 의미이다.

- 요소들의 이동을 화살표로 표시하면 다음과 같다.  `trucks`  →  `crossing`  → `crossed`

  - __`trucks`__

    - 아직 다리에 오르지 않고, 다리에 오르기를 기다리고 있는 트럭들의 리스트이다. 

    - 각 요소들은 `(트럭의 무게, 트럭이 이동한 거리)` 로 구성된 튜플이다. 

    - 인덱스가 작은 순으로 빠져나가므로 ` top = 0` 이고 `bottom = len(trucks)- 1` 인 __스택__이라고 볼 수 있다.

    - `trucks` 스택에서 `pop` 연산이 일어나기 위한 조건은 다음과 같다. 

      > `crossing` 스택의 요소들 중 `트럭이 이동한 거리` 가 `bridge_length` 보다 작은(`<`) 것들의 `트럭의 무게` 합이 `weight` 보다 같거나 작다면(`<=`) `truck` 스택의 `top` 포인터가 가리키는 요소의 `pop` 이 일어난다.

      - 예를 들어,  `time_passed = 2` 에서, (지금이 `2` 초의 시작이라는 뜻이 아니라 `2` 초간의 연산 __결과__라는 의미) 각 스택의 요소가 다음과 같다고 하자.
        - `trucks = [(4, 0), (5, 0), (6, 0)]` 
        - `crossing = [(7, 2)]` 
        - `crossed = []`
      - 다음 `while` 루프중에는 다음과 같은 판단과 연산이 진행된다.
        - `crossing` 의 요소 `(7, 2)`는 `2` 초동안 `bridge_length` 만큼 이동하였으므로, 다음 루프인 `2` ~ `3` 초 째에는  `crossed` 로 `push` 된다. 따라서 `trucks` 의 첫 번째 요소가 `crossing` 으로 `push` 되어도 `weight` 보다 작다. (`2` ~ `3` 초 에는 다리에 트럭이 한 대도 없다.)
        - 따라서,  `trucks` 첫 번째 요소인 `(4, 0)` 이 `pop` 되어 `crossing` 에 `push` 되며, 해당 루프의 최종 결과는 다음과 같다. `crossing` 에 `(4, 0)` 이 아니라 `(4, 1)` 이 `push` 된 이유는, 해당 루프의 결과로 해당 트럭이 `1`만큼 전진하였기 때문이다.
          - `trucks = [(5, 0), (6, 0)]` 
          - `crossing = [(4, 1)]` 
          - `crossed = [7, 3]`

    - `trucks` 스택에서 `pop` 된 요소는 `crossing` 스택으로 `push`(`append`) 된다.

  - __`crossing`__

    - 다리를 건너고 있는 트럭들의 리스트이다. 

    -  `trucks` 리스트에서 `pop` 된 튜플을 `push` 한 것을 요소로 한다. 

    - 인덱스가 작은 순으로 빠져나가므로  ` top = 0` 이고 `bottom = len(crossing) - 1` 인 __스택__이라고 볼 수 있다.

    - **매 `while` 루프마다 각 요소의 `트럭이 이동한 거리` 가 `1` 씩 증가**한다. 그 루프에 `crossing` 에 들어온 요소도 얄짤없이 `트럭이 이동한 거리`가 가 `1` 증가한다. 이는 매 초 다리위에 있는 트럭들 거리 `1` 씩 전진한다는 의미이다.

    - `crossing` 스텍에서 `pop` 연산이 일어나기 위한 조건은 다음과 같다. 

      > `crossing` 스택의 `top` 포인터가 가리키는 요소의 `트럭이 이동한 거리` 가 `bridge_length` 보다 큰(`>`) 경우 해당 요소의  `pop` 이 일어난다.

      - 여기서 헷갈렸던 것은 다음과 같다. `crossing`에 있는 요소의 `트럭이 이동한 거리` 가 `bridge_length` 와 같은 경우, 해당 트럭이 다리를 빠져 나간건지 아직도 다리를 건너는 중인건지 헷갈렸다. 
      - 결론적으로, 모든 `push` 와 `pop` 연산이 끝난 해당 `while` 문의 끄트머리에서의 `trucks`, `crossing`, `crossed` 의 요소들의 상태는 해당 순간의 스냅샷(결과)이라는 것이다. 예를 들어 `bridge_length` 가 `2` 인 경우, `0.0000` 초에 처음 다리에 진입한 트럭을 예로 들어보자. (사실 `0.000...1` 초에 다리에 진입하였다고 표현하는게 정확하리라.) `1.9999...` 초에서는 아직 `crossing` 상태이고, `2.0000`초가 된 순간 (`time_passed = 2` 인 상황) 에도 아직 `crossing` 상태이며, `2.000...1` 초가 된 순간 (바로 다음의 `while` 루프에 진입한 순간) 해당 트럭은 비로소 `crossed` 가 된다.
      - 따라서, 정확히 얘기하면 첫번째 케이스의 경우 `8` 초가 아니라 `7.000...1` 초에는 모든 트럭이 `crossed` 상태가 되지만, 이 경우 답을 낼 수가 없으므로 문제에서의 허용으로 __최소한__ `8` 초에는 모든 트럭이 다리를 건넜다고 표현하는 것 같다.

    - `crossing` 스택에서 `pop` 된 요소는 `crossed` 스택으로 `push`(`append`) 된다.

  - __`crossed`__

    - 다리를 완전히 건넌 트럭들의 리스트이다.
    - `crossing` 리스트에서 `pop` 된 튜플을 `push` 한 것을 요소로 한다. 

    

## 알게 된 것

- 리스트의 팝은 실제로 다음과 같은 형태이다. 

  > `LIST_NAME.pop(self, index = -1)`

- `index` 키워드 인자로는, `pop` 연산이 리스트의 어디에서 일어날지 결정한다. 예를 들어 다음과 같다. 딱히 설정하지 않으면 리스트의 최 우측 인덱스(`index = -1`)에서 일어난다.

  ```python
  >>> li = [0, 1, 2, 3, 4, 5, 6]
  >>> li.pop(3)
  3
  
  >>> li
  [0, 1, 2, 4, 5, 6]
  ```

  